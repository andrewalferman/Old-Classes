#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 19 14:27:09 2016

Authors: Andrew Alferman and Dan Magee

This code creates all of the required plots for problem 1 of ME526 HW#2 Fall 16
"""

# Import some of the libraries needed in order to solve all of the expressions
# of the modified wavefunctions, and to plot out the results.
import numpy as np
import matplotlib.pyplot as plt


# Creating five functions, one for each of the five approximations of the first
# derivative.  Each of the functions takes the value of k and delta_x, and
# returns the value of i * k_star * delta_x, abbreviated as iksdx.
# Note that j ---> i (sqrt(-1)) in Python.
def fn_one(k, delx):
    iksdx = 1 - np.cos(k * delx) + 1j*np.sin(k * delx)
    return iksdx


def fn_two(k, delx):
    iksdx = 1j * np.sin(k * delx)
    return iksdx


def fn_three(k, delx):
    iksdx = 1.5 - 2*np.cos(k * delx) + 2j*np.sin(k * delx) + \
            0.5*np.cos(2 * k * delx) - 0.5j*np.sin(2 * k * delx)
    return iksdx


def fn_four(k, delx):
    iksdx = (np.cos(3 * k * delx) - 1j*np.sin(3 * k * delx) -
             6*np.cos(2 * k * delx) + 6j*np.sin(2 * k * delx) +
             3*np.cos(k * delx) - 3j*np.sin(k * delx) + 2) * 0.1666666666666666
    return iksdx


def fn_five(k, delx):
    iksdx = (-1j*np.sin(2 * k * delx) + 8j*np.sin(k * delx)) * 0.16666666666666
    return iksdx


# Create a function that finds the actual value of k * delta_x
def fn_act(k, delx):
    kdx = k * delx
    return kdx


# Create a function that determines the error of a given input
def error(fn_value, delx):
    act = fn_act(1.0, delx)
    err = 100 * (np.absolute(fn_value - act)) / act
    return err

# Set the number of grid points
n_grid = 1000
n_grid_i = 1 / n_grid

# Define all of the values given to us in the problem
length = 2 * np.pi
delx = length / n_grid

# Create lists that will capture all of the information that will be plotted
kv, onei, twoi, threei, fouri, fivei, act, oner, twor, threer, fourr, fiver = \
    [], [], [], [], [], [], [], [], [], [], [], []

# Create all of the data points in a for loop for the imaginary numbers
for i in range(0, int(n_grid / 2 + 1)):
    wvn = 2 * np.pi * i * n_grid_i
    onei.append([wvn, (fn_one(i, delx)).imag])
    twoi.append([wvn, (fn_two(i, delx)).imag])
    threei.append([wvn, (fn_three(i, delx)).imag])
    fouri.append([wvn, (fn_four(i, delx)).imag])
    fivei.append([wvn, (fn_five(i, delx)).imag])
    oner.append([wvn, np.exp(-1 * (fn_one(i, delx)).real)])
    twor.append([wvn, np.exp(-1 * (fn_two(i, delx)).real)])
    threer.append([wvn, np.exp(-1 * (fn_three(i, delx)).real)])
    fourr.append([wvn, np.exp(-1 * (fn_four(i, delx)).real)])
    fiver.append([wvn, np.exp(-1 * (fn_five(i, delx)).real)])
    act.append([wvn, fn_act(i, delx)])

# Turn all of the lists into arrays so that they can be plotted easier
onei = np.array(onei)
twoi = np.array(twoi)
threei = np.array(threei)
fouri = np.array(fouri)
fivei = np.array(fivei)
oner = np.array(oner)
twor = np.array(twor)
threer = np.array(threer)
fourr = np.array(fourr)
fiver = np.array(fiver)
act = np.array(act)


# Print out all of the plots of the imaginary values of each function vs. act.
plt.plot(onei[:, 0], onei[:, 1], label="1")
plt.plot(twoi[:, 0], twoi[:, 1], label="2")
plt.plot(threei[:, 0], threei[:, 1], label="3")
plt.plot(fouri[:, 0], fouri[:, 1], label="4")
plt.plot(fivei[:, 0], fivei[:, 1], label="5")
plt.plot(act[:, 0], act[:, 1], label="Actual")
plt.ylabel("Function Value (Multiples of i)")
plt.xlabel("x Value")
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.title("Plot of Imaginary Parts vs. Actual")
plt.show()

# Print out all of the plots of the real values of each function vs. act.
plt.plot(oner[:, 0], oner[:, 1], label="1")
plt.plot(twor[:, 0], twor[:, 1], label="2")
plt.plot(threer[:, 0], threer[:, 1], label="3")
plt.plot(fourr[:, 0], fourr[:, 1], label="4")
plt.plot(fiver[:, 0], fiver[:, 1], label="5")
plt.plot(act[:, 0], act[:, 1], label="Actual")
plt.ylabel("Function Value")
plt.xlabel("x Value")
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.title("Plot of Real Parts vs. Actual")
plt.show()

# Initialize data capturing lists and k value for part d
sone, stwo, sthree, sfour, sfive = [], [], [], [], []
k = 1.0

# Iterate the error check function for a grid spacing range of 2 to 100
for d in range(2, 101):
    dlx = length / d
    sone.append([d, error(fn_one(k, dlx), dlx)])
    stwo.append([d, error(fn_two(k, dlx), dlx)])
    sthree.append([d, error(fn_three(k, dlx), dlx)])
    sfour.append([d, error(fn_four(k, dlx), dlx)])
    sfive.append([d, error(fn_five(k, dlx), dlx)])

# Turn all of the part d data capturing lists into arrays to be plotted
sone = np.array(sone)
stwo = np.array(stwo)
sthree = np.array(sthree)
sfour = np.array(sfour)
sfive = np.array(sfive)

# Plot all of the error functions
plt.loglog(sone[:, 0], sone[:, 1], label="1")
plt.loglog(stwo[:, 0], stwo[:, 1], label="2")
plt.loglog(sthree[:, 0], sthree[:, 1], label="3")
plt.loglog(sfour[:, 0], sfour[:, 1], label="4")
plt.loglog(sfive[:, 0], sfive[:, 1], label="5")
plt.ylabel("Absolute Error")
plt.xlabel("Grid Spacing N")
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.title("Error vs. N")
plt.show()
