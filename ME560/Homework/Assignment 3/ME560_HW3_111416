#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 31 11:47:02 2016

@author: Andrew Alferman and Nathan Schorn
"""

import numpy as np
import matplotlib.pyplot as plt

# Global variables
c = 0.5
meshpoints = 10
aoam = [0.0, 2.0, 5.0]
u = 1.0
p_inf = 101000
method = 1


# Create a function that uses the given equation to make vertexes for the
# panels. The function also finds the vortex points, colocation points, and
# angle outward (normal) from the panel.
def createaij(meshpoints, c):
    # Setting up lists for X coordinate (xc), eta coordinate (etac), vortex
    # coordinates (vcx/vcz), colocation point coordinates (clcx/clcz),
    # and angle normal to panel (ni)
    xc, etac, vcx, vcz, clcx, clcz, ni, plm = [], [], [], [], [], [], [], []
    # Initialize a few variables to create the points.
    x = 0
    dx = c / meshpoints
    c_i = 1 / c
    # Create all of the vertex points.
    for i in range(meshpoints + 1):
        xc.append(x)
        etac.append(0.2 * x * c_i * (1 - x*c_i)**3)
        x += dx
    # Create the vortex points, colocation points, normal angles, and lengths
    for i in range(1, len(xc)):
        vcx.append(xc[i] - 0.75*(xc[i]-xc[i-1]))
        vcz.append(etac[i] - 0.75*(etac[i]-etac[i-1]))
        clcx.append(xc[i] - 0.25*(xc[i]-xc[i-1]))
        clcz.append(etac[i] - 0.25*(etac[i]-etac[i-1]))
        ni.append(np.pi/2 + np.arctan((etac[i]-etac[i-1])/(xc[i]-xc[i-1])))
        plm.append(np.sqrt((xc[i]-xc[i-1])**2 + (etac[i]-etac[i-1])**2))
    # Create the aij matrix
    aij = []
    for i in range(len(vcx)):
        aijr = []
        for j in range(len(clcx)):
            lr = (clcx[i] - vcx[j])**2 + (clcz[i] - vcz[j])**2
            u = (1 / (2 * np.pi)) * (clcz[i] - vcz[j]) / lr
            w = (-1 / (2 * np.pi)) * (clcx[i] - vcx[j]) / lr
            n = [np.cos(ni[i]), np.sin(ni[i])]
            q = [u, w]
            aijr.append(np.dot(q, n))
        aij.append(aijr)
    aij = np.array(aij)
    return xc, etac, vcx, vcz, clcx, clcz, ni, aij, plm


# Create a function that finds the circulation across all the panels
def findgammas(ni, aij, aoa, u):
    umatrix = []
    for i in range(len(ni)):
        umatrix.append(-1 * np.dot([u * np.cos(np.radians(aoa)),
                                    u * np.sin(np.radians(aoa))],
                                   [np.cos(ni[i]), np.sin(ni[i])]))
    aiji = np.linalg.inv(aij)
    gammas = np.dot(aiji, umatrix)
    return gammas


def flatplate(meshpoints, c):
    # Setting up lists for X coordinate (xc), eta coordinate (etac), vortex
    # coordinates (vcx/vcz), colocation point coordinates (clcx/clcz),
    # and angle normal to panel (ni)
    xc, etac, vcx, vcz, clcx, clcz, ni, plm = [], [], [], [], [], [], [], []
    # Initialize a few variables to create the points.
    x = 0
    dx = c / meshpoints
    # Create all of the vertex points.
    for i in range(meshpoints + 1):
        xc.append(x)
        etac.append(0)
        x += dx
    # Create the vortex points, colocation points, normal angles, and lengths
    for i in range(1, len(xc)):
        vcx.append(xc[i] - 0.75*(xc[i]-xc[i-1]))
        vcz.append(0)
        clcx.append(xc[i] - 0.25*(xc[i]-xc[i-1]))
        clcz.append(0)
        ni.append(np.pi/2)
        plm.append(0.05)
    # Create the aij matrix
    aij = []
    for i in range(len(vcx)):
        aijr = []
        for j in range(len(clcx)):
            lr = (clcx[i] - vcx[j])**2
            u = 0
            w = (-1 / (2 * np.pi)) * (clcx[i] - vcx[j]) / lr
            n = [0, 1]
            q = [u, w]
            aijr.append(np.dot(q, n))
        aij.append(aijr)
    aij = np.array(aij)
    return xc, etac, vcx, vcz, clcx, clcz, ni, aij, plm


xc, etac, vcx, vcz, clcx, clcz, ni, aij, plm = createaij(meshpoints, c)
fxc, fetac, fvcx, fvcz, fclcx, fclcz, fni, faij, fplm =\
    flatplate(meshpoints, c)
tliftm, gammam, cpm = [], [], []
ftliftm, fgammam, fcpm = [], [], []
for i in aoam:
    cp = []
    fcp = []
    gammas = findgammas(ni, aij, i, u)
    gammam.append(np.ndarray.tolist(gammas))
    gammat = 0
    fgammas = findgammas(fni, faij, i, u)
    fgammam.append(np.ndarray.tolist(fgammas))
    fgammat = 0
    for j in range(len(gammas)):
        gammat += gammas[j]
        fgammat += fgammas[j]
    tliftm.append(gammat * u * 1000)
    ftliftm.append(fgammat * u * 1000)
    for k in range(len(gammas)):
        cp.append(2 * gammas[k] / (u * plm[k]))
        fcp.append(2 * fgammas[k] / (u * fplm[k]))
    cpm.append(cp)
    fcpm.append(fcp)
    plt.figure(1)
    plt.title('Circulation per Panel')
    plt.plot(vcx, gammas, label='AoA = {}'.format(i))
    plt.legend(bbox_to_anchor=(1, 1), loc=2)

    plt.figure(2)
    plt.title('Local Pressure Coefficient per Panel')
    plt.plot(clcx, cp, label='AoA = {}'.format(i))
    plt.legend(bbox_to_anchor=(1, 1), loc=2)
gammam = np.array(gammam)
fgammam = np.array(fgammam)

plt.figure(3)
plt.scatter(xc, etac, color='blue')
plt.xlabel('Length X (meters)', fontsize=12)
plt.ylabel('Width Z (meters)', fontsize=12)
plt.title('Panel Vertex Locations (Stretched in Y Direction)', fontsize=14)
plt.xlim(0, 0.5)

plt.figure(4)
plt.plot(xc, etac, color='blue')
plt.xlabel('Length X (meters)', fontsize=12)
plt.ylabel('Width Z (meters)', fontsize=12)
plt.title('Hydrofoil Shape (Stretched in Y Direction)', fontsize=14)
plt.xlim(0, 0.5)

for i in range(1, 5):
    plt.figure(i)
    plt.grid(b=True, which='both')
plt.show()

print('For 1m Span Length:')
for i in range(len(aoam)):
    print('Lift with AoA = {}: {:.2f}'.format(aoam[i], tliftm[i]))
    print('Flat Plate Lift with AoA = {}: {:.2f}'.format(aoam[i], ftliftm[i]))

# The code below just outputs the location of points in an easy to read format
vertexes, clc, vc = [], [], []
for i in range(len(clcx)):
    clc.append([clcx[i], clcz[i]])
    vc.append([vcx[i], vcz[i]])
for i in range(len(xc)):
    vertexes.append([xc[i], etac[i]])
vertexes = np.array(vertexes)
clc = np.array(clc)
vc = np.array(vc)
